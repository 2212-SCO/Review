var db = require('../db');
module.exports = {
  // a function which produces reviews
  getAll: function (query, callback) {
    let { product_id, sort, page, count } = query;
    page = Number(page) || 1;
    count = Number(count) || 5;
    const offset = (page - 1) * count;
    const params = [product_id, count, offset];
    if (sort === 'helpful') {
      var sortBy = 'ORDER BY r.helpfulness DESC';
    } else if (sort === 'newest') {
      var sortBy = 'ORDER BY r.date DESC';
    } else {
      var sortBy = 'ORDER BY r.date DESC, r.helpfulness DESC';
    }
    var queryString = `SELECT r.*, array_to_json(array_remove(array_agg(photos), NULL)) as photos FROM reviews r LEFT JOIN photos ON r.review_id = photos.review_id WHERE product_id = $1 AND reported = false GROUP BY r.review_id ${sortBy} LIMIT $2 OFFSET $3`;
    db.query(queryString, params)
      .catch(err => callback(err.stack, null))
      .then(res => {
        // console.log(res);
        const data = {
          'product': product_id,
          'page': page,
          'count': count,
          'results': res.rows
        }
        callback(null, data)
      })
  },

  getMeta: function (query, callback) {
    const { product_id } = query;
    //calculate rating distribution
    const params = [product_id];
    var queryString1 = `WITH ratings_d AS ( SELECT product_id, rating, count(rating) as frequency FROM reviews WHERE product_id = $1 AND reported = false GROUP BY product_id, rating ), recommended_d AS ( SELECT product_id, recommend, count(recommend) as frequency FROM reviews WHERE product_id = $1 AND reported = false GROUP BY product_id, recommend ), characteristic_d AS ( SELECT c.product_id, c."name", jsonb_build_object('id', c.id, 'value', AVG(cr."value")::text) AS avgvalue FROM characteristic_reviews cr JOIN reviews r ON r.review_id = cr.review_id AND r.reported = false JOIN characteristics c ON cr.characteristic_id = c.id WHERE c.product_id = $1 GROUP BY c.product_id, c.id, c."name" )`;
    var queryString2 = `SELECT ratings_d.product_id::text, jsonb_object_agg(ratings_d.rating, ratings_d.frequency::text) AS ratings, jsonb_object_agg(recommended_d.recommend, recommended_d.frequency::text) AS recommended, jsonb_object_agg(characteristic_d.name, characteristic_d.avgvalue) AS characteristics FROM ratings_d JOIN recommended_d ON ratings_d.product_id = recommended_d.product_id JOIN characteristic_d ON ratings_d.product_id = characteristic_d.product_id GROUP BY ratings_d.product_id`;
    var queryString = queryString1 + queryString2;
    db.query(queryString, params)
      .catch(err => callback(err.stack, null))
      .then(res => {
        if (res.rows.length === 0) {
          const obj = {
            "product_id": product_id.toString(),
            "ratings": {},
            "recommended": {},
            "characteristics": {}
          }
          callback(null, obj)
        } else {
          callback(null, res.rows[0])
        }
      })
  },

  setHelpful: function (query, callback) {
    const { review_id } = query;
    const params = [review_id];
    var queryString = `UPDATE reviews SET helpfulness = helpfulness + 1 WHERE review_id = $1`;
    db.query(queryString, params)
      .catch(err => callback(err.stack, null))
      .then(res => callback(null, res))
  },

  setReport: function (query, callback) {
    const { review_id } = query;
    console.log('review_id: ', review_id);
    const params = [review_id];
    var queryString = `UPDATE reviews SET reported = true WHERE review_id = $1`;
    db.query(queryString, params)
      .catch(err => callback(err.stack, null))
      .then(res => callback(null, res))
  },

  postReview: async function (query, callback) {
    try {
      console.log('review: ', query);
      const params = [query.product_id, query.rating, query.summary, query.body, query.recommend, query.name, query.email];

      // First, insert into the `reviews` table
      var queryString1 = `INSERT INTO reviews (product_id, rating, summary, body, recommend, review_name, reviewer_email)
      VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING review_id`;
      const reviewInsertResult = await db.query(queryString1, params);
      // Get the review_id generated by the first query
      const review_id = reviewInsertResult.rows[0].review_id;

      // Second, insert into the `photos` table
      console.log('query.photos.length: ', query.photos.length)
      if (query.photos.length) {
        var queryString2 = `INSERT INTO photos (review_id, url) VALUES `;

        for (let i = 0; i < query.photos.length; i++) {
          if (i === 0) {
            queryString2 += `(${review_id}, '${query.photos[i]}')`;
          } else {
            queryString2 += `, (${review_id}, '${query.photos[i]}')`;
          }
        }
        queryString2 += `;`;
        console.log('queryString2: ', queryString2);
        await db.query(queryString2);
      }

      //Third, insert into the `characteristic_reviews` table
      const characteristics = query.characteristics;
      if (Object.keys(characteristics).length > 0) {
        var queryString3 = `INSERT INTO characteristic_reviews (characteristic_id, review_id, value) VALUES `;
        for (let [key, value] of Object.entries(characteristics)) {
          queryString3 += `(${key}, ${review_id}, ${value})`;
            queryString3 += ',';
        }
        queryString3 = queryString3.slice(0, queryString3.length - 1);
        console.log('queryString3: ', queryString3);
        await db.query(queryString3);
      }
      callback(null, 'posted');

    } catch (error) {
      callback(error.stack, null);
    }
  }
};